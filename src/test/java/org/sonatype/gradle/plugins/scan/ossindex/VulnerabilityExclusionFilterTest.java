/*
 * Copyright (c) 2020-present Sonatype, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.sonatype.gradle.plugins.scan.ossindex;

import java.net.URI;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;
import org.sonatype.goodies.packageurl.PackageUrlBuilder;
import org.sonatype.ossindex.service.api.componentreport.ComponentReport;
import org.sonatype.ossindex.service.api.componentreport.ComponentReportVulnerability;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import org.junit.Before;
import org.junit.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class VulnerabilityExclusionFilterTest
{
  private static final PackageUrl PACKAGE_URL = new PackageUrlBuilder()
      .type("maven")
      .namespace("ns1")
      .name("n1")
      .version("b1")
      .build();

  private static final Set<String> VULNERABILITY_IDS = ImmutableSet.of("ABC-123");

  private static final Set<PackageUrl> COORDINATES = ImmutableSet.of(PACKAGE_URL);

  private Map<PackageUrl, ComponentReport> componentReportMap;

  private ComponentReportVulnerability vulnerability1;

  private ComponentReportVulnerability vulnerability2;

  @Before
  public void setup() throws Exception {
    componentReportMap = new HashMap<>();
    componentReportMap.put(PACKAGE_URL, setupComponentReport());
  }

  @Test
  public void testApply_excludeByCoordinate() {
    VulnerabilityExclusionFilter filter = new VulnerabilityExclusionFilter(Collections.emptySet(), COORDINATES);
    filter.apply(componentReportMap);
    assertThat(componentReportMap).containsKey(PACKAGE_URL);
    List<ComponentReportVulnerability> vulnerabilities = componentReportMap.get(PACKAGE_URL).getVulnerabilities();
    assertThat(vulnerabilities).isEmpty();
  }

  @Test
  public void testApply_excludeByVulnerabilityId() {
    VulnerabilityExclusionFilter filter = new VulnerabilityExclusionFilter(VULNERABILITY_IDS, Collections.emptySet());
    filter.apply(componentReportMap);

    List<ComponentReportVulnerability> vulnerabilities = componentReportMap.get(PACKAGE_URL).getVulnerabilities();
    assertThat(vulnerabilities).hasSize(1);
    assertThat(vulnerabilities).doesNotContain(vulnerability1);
    assertThat(vulnerabilities).contains(vulnerability2);
  }

  private ComponentReport setupComponentReport() throws Exception {
    ComponentReport componentReport = new ComponentReport();
    componentReport.setCoordinates(PACKAGE_URL);

    vulnerability1 = new ComponentReportVulnerability();
    vulnerability1.setId("ABC-123");
    vulnerability1.setTitle("Title 1");
    vulnerability1.setCvssScore(4f);
    vulnerability1.setReference(new URI("http://test/123"));

    vulnerability2 = new ComponentReportVulnerability();
    vulnerability2.setId("DEF-456");
    vulnerability2.setTitle("Title 2");
    vulnerability2.setCvssScore(6f);
    vulnerability2.setReference(new URI("http://test/456"));

    componentReport.setVulnerabilities(Lists.newArrayList(vulnerability1, vulnerability2));
    return componentReport;
  }
}
